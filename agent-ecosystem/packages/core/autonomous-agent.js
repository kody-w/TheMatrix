/**
 * AUTONOMOUS AGENT CORE
 * Generated by The Matrix - Meta-Orchestration System
 *
 * This is the central orchestrator that integrates all 70 components
 * across 7 specialized packages into a cohesive autonomous agent.
 */

const EventEmitter = require('events');
const { MemorySystem } = require('../memory-systems');
const { ToolRegistry } = require('../tool-integration');
const { PlanningEngine } = require('../planning-reasoning');
const { MultiAgentCoordinator } = require('../multi-agent');
const { HumanInLoop } = require('../human-in-loop');
const { ObservabilityTracker } = require('../observability');
const { SafetyGuardrails } = require('../safety-guardrails');

class AutonomousAgent extends EventEmitter {
  constructor(config = {}) {
    super();

    this.id = config.id || `agent-${Date.now()}`;
    this.name = config.name || 'UnnamedAgent';
    this.goal = null;
    this.status = 'idle'; // idle, planning, executing, paused, completed, failed

    // Initialize all 7 core packages
    this.memory = new MemorySystem(config.memory || {});
    this.tools = new ToolRegistry(config.tools || {});
    this.planner = new PlanningEngine(config.planning || {});
    this.coordinator = new MultiAgentCoordinator(config.multiAgent || {});
    this.humanInterface = new HumanInLoop(config.humanInLoop || {});
    this.observability = new ObservabilityTracker(config.observability || {});
    this.safety = new SafetyGuardrails(config.safety || {});

    // Execution state
    this.currentPlan = null;
    this.executionHistory = [];
    this.iteration = 0;
    this.maxIterations = config.maxIterations || 50;

    // Connect event streams
    this._connectEventStreams();

    this.emit('agent:created', { id: this.id, name: this.name });
  }

  /**
   * Set the agent's goal and generate initial plan
   */
  async setGoal(goalDescription) {
    this.goal = goalDescription;
    this.status = 'planning';
    this.emit('goal:set', { goal: goalDescription });

    // Store goal in long-term memory
    await this.memory.storeLongTerm({
      type: 'goal',
      content: goalDescription,
      timestamp: Date.now()
    });

    // Generate initial plan using planning engine
    this.currentPlan = await this.planner.createPlan(goalDescription, {
      memory: this.memory,
      tools: this.tools.getAvailableTools(),
      constraints: this.safety.getConstraints()
    });

    this.emit('plan:created', { plan: this.currentPlan });

    return this.currentPlan;
  }

  /**
   * Execute the agent autonomously until goal is reached
   */
  async execute() {
    if (!this.goal) {
      throw new Error('Cannot execute without a goal. Call setGoal() first.');
    }

    this.status = 'executing';
    this.emit('execution:started', { goal: this.goal });

    const startTime = Date.now();

    try {
      while (this.iteration < this.maxIterations && this.status === 'executing') {
        this.iteration++;

        // Get next action from current plan
        const action = await this.planner.getNextAction(this.currentPlan, {
          memory: this.memory,
          history: this.executionHistory
        });

        if (!action) {
          // No more actions - goal achieved or stuck
          const isGoalAchieved = await this._checkGoalAchievement();

          if (isGoalAchieved) {
            this.status = 'completed';
            break;
          } else {
            // Replan
            this.currentPlan = await this.planner.replan(this.goal, {
              memory: this.memory,
              history: this.executionHistory,
              reason: 'stuck_no_more_actions'
            });
            continue;
          }
        }

        // Safety check - does this action require approval?
        if (await this.safety.requiresApproval(action)) {
          const approved = await this.humanInterface.requestApproval({
            action: action,
            context: this._getContext()
          });

          if (!approved) {
            this.emit('action:rejected', { action });
            // Replan without this action
            this.currentPlan = await this.planner.replan(this.goal, {
              memory: this.memory,
              history: this.executionHistory,
              reason: 'action_rejected',
              rejectedAction: action
            });
            continue;
          }
        }

        // Execute the action
        const result = await this._executeAction(action);

        // Store in memory
        await this.memory.storeEpisode({
          iteration: this.iteration,
          action: action,
          result: result,
          timestamp: Date.now()
        });

        // Update execution history
        this.executionHistory.push({
          action,
          result,
          iteration: this.iteration
        });

        // Self-reflection: Did this action help?
        const reflection = await this.planner.reflect(action, result, this.goal);

        if (reflection.shouldReplan) {
          this.currentPlan = await this.planner.replan(this.goal, {
            memory: this.memory,
            history: this.executionHistory,
            reason: reflection.reason
          });
        }

        // Emit progress
        this.emit('iteration:complete', {
          iteration: this.iteration,
          action,
          result,
          reflection
        });
      }

      // Execution completed
      const executionTime = Date.now() - startTime;

      const summary = {
        status: this.status,
        goal: this.goal,
        iterations: this.iteration,
        executionTime,
        actionsPerformed: this.executionHistory.length,
        finalPlan: this.currentPlan,
        result: await this._generateSummary()
      };

      this.emit('execution:completed', summary);

      return summary;

    } catch (error) {
      this.status = 'failed';
      this.emit('execution:failed', { error: error.message, stack: error.stack });
      throw error;
    }
  }

  /**
   * Execute a single action using the appropriate tool
   */
  async _executeAction(action) {
    this.emit('action:starting', { action });

    const startTime = Date.now();

    try {
      // Check safety constraints
      await this.safety.validateAction(action);

      // Get the tool
      const tool = this.tools.getTool(action.tool);

      if (!tool) {
        throw new Error(`Tool not found: ${action.tool}`);
      }

      // Execute with observability
      const result = await this.observability.trackExecution(
        action.tool,
        async () => await tool.execute(action.parameters)
      );

      const executionTime = Date.now() - startTime;

      this.emit('action:completed', {
        action,
        result,
        executionTime
      });

      return {
        success: true,
        data: result,
        executionTime
      };

    } catch (error) {
      const executionTime = Date.now() - startTime;

      this.emit('action:failed', {
        action,
        error: error.message,
        executionTime
      });

      return {
        success: false,
        error: error.message,
        executionTime
      };
    }
  }

  /**
   * Check if the goal has been achieved
   */
  async _checkGoalAchievement() {
    // Use the planner's goal checker
    const achieved = await this.planner.isGoalAchieved(this.goal, {
      memory: this.memory,
      history: this.executionHistory
    });

    return achieved;
  }

  /**
   * Generate execution summary
   */
  async _generateSummary() {
    const successfulActions = this.executionHistory.filter(h => h.result.success);
    const failedActions = this.executionHistory.filter(h => !h.result.success);

    const toolsUsed = new Set(this.executionHistory.map(h => h.action.tool));

    const totalCost = await this.observability.getTotalCost();
    const resourcesUsed = await this.observability.getResourceSummary();

    return {
      goalAchieved: this.status === 'completed',
      totalActions: this.executionHistory.length,
      successfulActions: successfulActions.length,
      failedActions: failedActions.length,
      toolsUsed: Array.from(toolsUsed),
      iterations: this.iteration,
      cost: totalCost,
      resources: resourcesUsed,
      executionTrace: this.executionHistory.map(h => ({
        action: h.action.name,
        tool: h.action.tool,
        success: h.result.success
      }))
    };
  }

  /**
   * Get current execution context
   */
  _getContext() {
    return {
      goal: this.goal,
      iteration: this.iteration,
      status: this.status,
      recentActions: this.executionHistory.slice(-5),
      currentPlan: this.currentPlan
    };
  }

  /**
   * Connect event streams between packages
   */
  _connectEventStreams() {
    // Forward important events to observability
    this.on('action:completed', (data) => this.observability.logAction(data));
    this.on('action:failed', (data) => this.observability.logError(data));
    this.on('plan:created', (data) => this.observability.logPlan(data));

    // Forward safety violations
    this.safety.on('violation', (data) => {
      this.emit('safety:violation', data);
      this.humanInterface.alert('safety_violation', data);
    });

    // Forward human interface requests
    this.humanInterface.on('user_input', (data) => {
      this.emit('human:input', data);
    });
  }

  /**
   * Pause execution
   */
  pause() {
    if (this.status === 'executing') {
      this.status = 'paused';
      this.emit('execution:paused');
    }
  }

  /**
   * Resume execution
   */
  async resume() {
    if (this.status === 'paused') {
      this.status = 'executing';
      this.emit('execution:resumed');
      return await this.execute();
    }
  }

  /**
   * Stop execution
   */
  stop() {
    this.status = 'idle';
    this.emit('execution:stopped');
  }

  /**
   * Get agent status and statistics
   */
  getStatus() {
    return {
      id: this.id,
      name: this.name,
      status: this.status,
      goal: this.goal,
      iteration: this.iteration,
      maxIterations: this.maxIterations,
      actionsPerformed: this.executionHistory.length,
      uptime: this.observability.getUptime(),
      memoryUsage: this.memory.getStats(),
      toolsAvailable: this.tools.getAvailableTools().length
    };
  }
}

module.exports = { AutonomousAgent };

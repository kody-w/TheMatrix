<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>üèõÔ∏è The Matrix Cathedral - 3D Experience</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .cathedral-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
        }

        .cathedral-title {
            font-size: 3em;
            font-weight: 100;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .cathedral-description {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.7);
            max-width: 500px;
            line-height: 1.6;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.5em;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 200;
            letter-spacing: 0.2em;
            z-index: 2000;
        }

        .loading::after {
            content: '';
            display: block;
            width: 80px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #667eea, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }

        .controls-hint {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 30px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 25px;
            border: 2px solid rgba(102, 126, 234, 0.5);
            backdrop-filter: blur(10px);
            z-index: 1001;
            text-align: center;
            animation: fadeIn 2s ease-in, fadeOut 1s ease-out 8s forwards;
        }

        .controls-hint p {
            margin: 5px 0;
            font-size: 0.95em;
            opacity: 0.9;
        }

        .controls-hint strong {
            color: #667eea;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, 20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; pointer-events: none; }
        }

        .demo-info-panel {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid rgba(102, 126, 234, 0.5);
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            z-index: 1002;
            backdrop-filter: blur(10px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s, transform 0.4s;
        }

        .demo-info-panel.active {
            opacity: 1;
            pointer-events: all;
            transform: translateY(-50%) translateX(0);
        }

        .demo-info-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .demo-info-close:hover {
            opacity: 1;
        }

        .demo-info-icon {
            font-size: 4em;
            margin-bottom: 15px;
        }

        .demo-info-category {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .category-software { background: rgba(16, 185, 129, 0.3); color: #10b981; }
        .category-content { background: rgba(59, 130, 246, 0.3); color: #3b82f6; }
        .category-creative { background: rgba(168, 85, 247, 0.3); color: #a855f7; }
        .category-meta { background: rgba(236, 72, 153, 0.3); color: #ec4899; }

        .demo-info-title {
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .demo-info-tagline {
            font-size: 1.1em;
            opacity: 0.8;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .demo-metrics {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .metric {
            flex: 1;
            min-width: 100px;
        }

        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
            display: block;
        }

        .metric-label {
            font-size: 0.85em;
            opacity: 0.7;
        }

        .demo-features {
            list-style: none;
            margin-bottom: 25px;
        }

        .demo-features li {
            padding: 8px 0;
            opacity: 0.8;
            line-height: 1.4;
        }

        .demo-features li::before {
            content: '‚úì ';
            color: #10b981;
            font-weight: bold;
            margin-right: 8px;
        }

        .launch-demo-btn {
            display: block;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            font-weight: 600;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            text-align: center;
        }

        .launch-demo-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
        }

        .stats-panel {
            position: fixed;
            top: env(safe-area-inset-top, 20px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(102, 126, 234, 0.4);
            border-radius: 15px;
            padding: 20px;
            z-index: 1001;
            backdrop-filter: blur(10px);
        }

        .stats-panel h3 {
            font-size: 1em;
            margin-bottom: 15px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-item {
            margin-bottom: 12px;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
            display: block;
        }

        .stat-label {
            font-size: 0.85em;
            opacity: 0.8;
        }

        .back-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 80px);
            left: env(safe-area-inset-left, 20px);
            padding: 12px 25px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            color: #fff;
            text-decoration: none;
            font-weight: 600;
            z-index: 1001;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-5px);
        }

        @media (max-width: 768px) {
            .cathedral-title {
                font-size: 2em;
            }

            .cathedral-description {
                font-size: 1em;
            }

            .demo-info-panel {
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .stats-panel {
                padding: 15px;
            }

            .controls-hint {
                font-size: 0.85em;
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>

    <div class="cathedral-ui">
        <h1 class="cathedral-title">THE CATHEDRAL</h1>
        <p class="cathedral-description">
            Walk through the sacred halls of parallel orchestration.<br>
            Each window reveals a demonstration of The Matrix's power.
        </p>
    </div>

    <div class="stats-panel">
        <h3>Cathedral Metrics</h3>
        <div class="stat-item">
            <span class="stat-value">7</span>
            <span class="stat-label">Demonstrations</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">12,000+</span>
            <span class="stat-label">Artifacts</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">500√ó</span>
            <span class="stat-label">Multiplier</span>
        </div>
    </div>

    <div class="controls-hint">
        <p><strong>Desktop:</strong> Click & drag to look around ‚Ä¢ WASD/Arrows to move ‚Ä¢ ESC to close</p>
        <p><strong>Mobile:</strong> Swipe to look around ‚Ä¢ Tap windows to explore</p>
    </div>

    <a href="index.html" class="back-button">‚Üê Back to Gateway</a>

    <div class="demo-info-panel" id="demoInfoPanel">
        <button class="demo-info-close" onclick="closeDemoInfo()">√ó</button>
        <div id="demoInfoContent"></div>
    </div>

    <div class="loading" id="loading">Constructing Cathedral...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const demos = [
            {
                icon: 'üöÄ',
                category: 'software',
                title: 'The Great Migration',
                tagline: '2,500 legacy PHP files transformed to modern React stack',
                metrics: [
                    { value: '2,500', label: 'Files Migrated' },
                    { value: '10', label: 'Parallel Agents' },
                    { value: '250√ó', label: 'Faster' }
                ],
                features: [
                    'Real-time migration progress visualization',
                    'Agent coordination dashboard',
                    'Generated React components preview',
                    'Time & cost savings calculator'
                ],
                file: 'the-great-migration.html',
                color: 0x10b981
            },
            {
                icon: '‚ú®',
                category: 'creative',
                title: 'Universe Architect',
                tagline: 'From story concept to 300 interconnected world elements',
                metrics: [
                    { value: '300', label: 'World Elements' },
                    { value: '10', label: 'Builder Agents' },
                    { value: '900', label: 'Hours Generated' }
                ],
                features: [
                    'Character, location & lore generation',
                    'Automatic relationship mapping',
                    'Multi-category worldbuilding system',
                    'Interactive element explorer'
                ],
                file: 'universe-architect.html',
                color: 0xa855f7
            },
            {
                icon: 'üß†',
                category: 'content',
                title: 'Knowledge Synthesizer',
                tagline: '75 research papers synthesized into 200 comprehensive articles',
                metrics: [
                    { value: '200', label: 'Articles' },
                    { value: '75', label: 'Papers' },
                    { value: '800', label: 'Research Hours' }
                ],
                features: [
                    'Multi-paper synthesis engine',
                    'Cross-reference tracking system',
                    'Citation management automation',
                    'Knowledge graph visualization'
                ],
                file: 'knowledge-synthesizer.html',
                color: 0x3b82f6
            },
            {
                icon: '‚öôÔ∏è',
                category: 'software',
                title: 'API Factory',
                tagline: 'Requirements to 500 production-ready endpoints across 50 services',
                metrics: [
                    { value: '500', label: 'Endpoints' },
                    { value: '50', label: 'Services' },
                    { value: '3,000', label: 'Dev Hours' }
                ],
                features: [
                    'REST API generation from specs',
                    'OpenAPI specifications included',
                    'Automated tests & documentation',
                    'Service mesh ready architecture'
                ],
                file: 'api-factory.html',
                color: 0x10b981
            },
            {
                icon: '‚ö°',
                category: 'meta',
                title: 'Automation Cascade',
                tagline: '50 processes automated with 300 artifacts via meta-orchestration',
                metrics: [
                    { value: '300', label: 'Artifacts' },
                    { value: '50', label: 'Processes' },
                    { value: '3', label: 'Levels Deep' }
                ],
                features: [
                    'Hierarchical orchestration system',
                    'Autonomous sub-orchestrator spawning',
                    'Workflow automation engine',
                    'Multi-level coordination dashboard'
                ],
                file: 'automation-cascade.html',
                color: 0xec4899
            },
            {
                icon: 'üìö',
                category: 'content',
                title: 'Documentation Engine',
                tagline: '3,500 code files analyzed to generate 400 documentation pages',
                metrics: [
                    { value: '400', label: 'Doc Pages' },
                    { value: '3,500', label: 'Files' },
                    { value: '4,800', label: 'Cross-Links' }
                ],
                features: [
                    'Automatic code analysis & extraction',
                    'API documentation generation',
                    'Search index creation',
                    'Multi-section organization system'
                ],
                file: 'documentation-engine.html',
                color: 0x3b82f6
            },
            {
                icon: 'üé®',
                category: 'software',
                title: 'Component Library',
                tagline: 'Design system to 100 production-ready React components',
                metrics: [
                    { value: '100', label: 'Components' },
                    { value: '400', label: 'Stories' },
                    { value: '98%', label: 'Test Coverage' }
                ],
                features: [
                    'TypeScript component generation',
                    'Storybook integration included',
                    'WCAG 2.1 accessibility compliant',
                    'Design token system implemented'
                ],
                file: 'component-library.html',
                color: 0x10b981
            }
        ];

        class CathedralExperience {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.clock = new THREE.Clock();

                this.cameraRotation = { x: 0, y: 0 };
                this.cameraPosition = { x: 0, y: 5, z: 30 };
                this.targetCameraRotation = { x: 0, y: 0 };

                this.isDragging = false;
                this.dragThreshold = 5; // Pixels moved before considering it a drag
                this.dragDistance = 0;
                this.previousMousePosition = { x: 0, y: 0 };

                this.moveForward = false;
                this.moveBackward = false;
                this.moveLeft = false;
                this.moveRight = false;

                this.windows = [];
                this.hoveredWindow = null;

                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                // Performance optimization flags
                this.isLowPerformance = this.isMobile || navigator.hardwareConcurrency <= 2;
                this.lastHoverCheck = 0;
                this.hoverCheckInterval = 100; // ms

                this.init();
            }

            init() {
                this.setupScene();
                this.setupLighting();
                this.createCathedral();
                this.createStainedGlassWindows();
                this.setupEventListeners();

                // Store instance for cleanup
                window.cathedralInstance = this;

                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1500);

                this.animate();
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x0a0a0f, 0.015); // Exponential fog for better depth
                this.scene.background = new THREE.Color(0x0a0a0f);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 5, 30);

                // Optimize renderer for mobile
                this.renderer = new THREE.WebGLRenderer({
                    antialias: !this.isLowPerformance,
                    powerPreference: 'high-performance',
                    stencil: false,
                    depth: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, this.isLowPerformance ? 1 : 2));
                this.renderer.shadowMap.enabled = !this.isLowPerformance;
                if (this.renderer.shadowMap.enabled) {
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                }
                document.getElementById('three-container').appendChild(this.renderer.domElement);
            }

            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.5);
                this.scene.add(ambientLight);

                // Main directional light (god rays effect)
                const dirLight = new THREE.DirectionalLight(0x667eea, 1.5);
                dirLight.position.set(0, 30, 0);

                if (!this.isLowPerformance) {
                    dirLight.castShadow = true;
                    dirLight.shadow.mapSize.width = 1024;
                    dirLight.shadow.mapSize.height = 1024;
                    dirLight.shadow.camera.left = -50;
                    dirLight.shadow.camera.right = 50;
                    dirLight.shadow.camera.top = 50;
                    dirLight.shadow.camera.bottom = -50;
                    dirLight.shadow.bias = -0.0001;
                }
                this.scene.add(dirLight);

                // Accent lights for atmosphere
                const purpleLight = new THREE.PointLight(0x764ba2, 1, 50);
                purpleLight.position.set(-20, 10, 0);
                this.scene.add(purpleLight);

                const blueLight = new THREE.PointLight(0x667eea, 1, 50);
                blueLight.position.set(20, 10, 0);
                this.scene.add(blueLight);

                // Add subtle hemisphere light for better ambient fill
                const hemiLight = new THREE.HemisphereLight(0x667eea, 0x16213e, 0.3);
                this.scene.add(hemiLight);
            }

            createCathedral() {
                // Floor
                const floorGeometry = new THREE.PlaneGeometry(100, 100);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x16213e,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);

                // Cathedral walls
                const wallMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a1a2e,
                    roughness: 0.9,
                    metalness: 0.1
                });

                // Left wall
                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 30, 60),
                    wallMaterial
                );
                leftWall.position.set(-25, 15, 0);
                leftWall.castShadow = true;
                this.scene.add(leftWall);

                // Right wall
                const rightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 30, 60),
                    wallMaterial
                );
                rightWall.position.set(25, 15, 0);
                rightWall.castShadow = true;
                this.scene.add(rightWall);

                // Back wall
                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(50, 30, 1),
                    wallMaterial
                );
                backWall.position.set(0, 15, -30);
                backWall.castShadow = true;
                this.scene.add(backWall);

                // Ceiling arches
                this.createCeilingArches();

                // Atmospheric particles
                this.createParticles();

                // Pillars
                this.createPillars();
            }

            createCeilingArches() {
                const archMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2a2a3e,
                    roughness: 0.7,
                    metalness: 0.3
                });

                for (let i = -20; i <= 20; i += 10) {
                    const arch = new THREE.Mesh(
                        new THREE.TorusGeometry(5, 0.5, 16, 100, Math.PI),
                        archMaterial
                    );
                    arch.rotation.z = Math.PI;
                    arch.position.set(0, 20, i);
                    this.scene.add(arch);
                }
            }

            createPillars() {
                const pillarMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2a2a3e,
                    roughness: 0.8,
                    metalness: 0.2
                });

                const positions = [
                    [-15, 0, -20], [15, 0, -20],
                    [-15, 0, 0], [15, 0, 0],
                    [-15, 0, 20], [15, 0, 20]
                ];

                positions.forEach(pos => {
                    const pillar = new THREE.Mesh(
                        new THREE.CylinderGeometry(1, 1.2, 25, 8),
                        pillarMaterial
                    );
                    pillar.position.set(pos[0], 12.5, pos[1]);
                    pillar.castShadow = true;
                    this.scene.add(pillar);

                    // Pillar capital
                    const capital = new THREE.Mesh(
                        new THREE.CylinderGeometry(1.5, 1, 2, 8),
                        pillarMaterial
                    );
                    capital.position.set(pos[0], 24, pos[1]);
                    this.scene.add(capital);
                });
            }

            createParticles() {
                const particleGeometry = new THREE.BufferGeometry();
                // Reduce particles on low performance devices
                const particleCount = this.isLowPerformance ? 200 : 500;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 50;
                    positions[i + 1] = Math.random() * 30;
                    positions[i + 2] = (Math.random() - 0.5) * 60;

                    colors[i] = 0.4 + Math.random() * 0.3;
                    colors[i + 1] = 0.3 + Math.random() * 0.4;
                    colors[i + 2] = 0.6 + Math.random() * 0.4;

                    // Add subtle floating velocities
                    velocities[i] = (Math.random() - 0.5) * 0.02;
                    velocities[i + 1] = Math.random() * 0.01;
                    velocities[i + 2] = (Math.random() - 0.5) * 0.02;
                }

                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: this.isLowPerformance ? 0.12 : 0.15,
                    transparent: true,
                    opacity: 0.6,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                this.particles = new THREE.Points(particleGeometry, particleMaterial);
                this.scene.add(this.particles);
            }

            createStainedGlassWindows() {
                const spacing = 8;
                const startZ = -24;
                const windowsPerSide = Math.ceil(demos.length / 2);

                demos.forEach((demo, index) => {
                    const isLeftSide = index % 2 === 0;
                    const sideIndex = Math.floor(index / 2);

                    const windowGroup = new THREE.Group();

                    // Window frame
                    const frameGeometry = new THREE.BoxGeometry(0.3, 8, 5);
                    const frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0x2a2a3e,
                        roughness: 0.3,
                        metalness: 0.7
                    });
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    windowGroup.add(frame);

                    // Stained glass with enhanced material
                    const glassGeometry = new THREE.PlaneGeometry(4.5, 7.5);
                    const glassMaterial = new THREE.MeshStandardMaterial({
                        color: demo.color,
                        emissive: demo.color,
                        emissiveIntensity: 0.4,
                        transparent: true,
                        opacity: 0.75,
                        side: THREE.DoubleSide,
                        roughness: 0.2,
                        metalness: 0.1,
                        envMapIntensity: 0.5
                    });
                    const glass = new THREE.Mesh(glassGeometry, glassMaterial);
                    glass.position.set(isLeftSide ? -0.2 : 0.2, 0, 0);
                    glass.rotation.y = isLeftSide ? Math.PI / 2 : -Math.PI / 2;
                    windowGroup.add(glass);

                    // Glow effect
                    const glowLight = new THREE.PointLight(demo.color, 1.5, 10);
                    glowLight.position.set(isLeftSide ? -2 : 2, 0, 0);
                    windowGroup.add(glowLight);

                    // Position the window
                    const xPos = isLeftSide ? -24.5 : 24.5;
                    const zPos = startZ + (sideIndex * spacing);
                    windowGroup.position.set(xPos, 10, zPos);

                    this.scene.add(windowGroup);

                    // Store window data for interaction
                    this.windows.push({
                        mesh: glass,
                        demo: demo,
                        group: windowGroup,
                        light: glowLight
                    });

                    // Add demo icon as 3D text (simplified)
                    this.createWindowLabel(windowGroup, demo, isLeftSide);
                });
            }

            createWindowLabel(windowGroup, demo, isLeftSide) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 256;

                context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                context.fillRect(0, 0, canvas.width, canvas.height);

                context.font = 'bold 80px Arial';
                context.fillStyle = '#ffffff';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(demo.icon, 256, 90);

                context.font = 'bold 32px Arial';
                context.fillText(demo.title, 256, 180);

                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true
                });
                const labelGeometry = new THREE.PlaneGeometry(4, 2);
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                label.position.set(isLeftSide ? 0.5 : -0.5, -5, 0);
                label.rotation.y = isLeftSide ? Math.PI / 2 : -Math.PI / 2;
                windowGroup.add(label);
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Mouse controls with improved drag detection
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    this.isDragging = false;
                    this.dragDistance = 0;
                    this.previousMousePosition = { x: e.clientX, y: e.clientY };
                });

                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                    if (this.previousMousePosition.x !== 0) {
                        const deltaX = e.clientX - this.previousMousePosition.x;
                        const deltaY = e.clientY - this.previousMousePosition.y;
                        this.dragDistance += Math.abs(deltaX) + Math.abs(deltaY);

                        // Only consider it dragging if moved beyond threshold
                        if (this.dragDistance > this.dragThreshold) {
                            this.isDragging = true;

                            this.targetCameraRotation.y -= deltaX * 0.003;
                            this.targetCameraRotation.x -= deltaY * 0.003;
                            this.targetCameraRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, this.targetCameraRotation.x));
                        }

                        this.previousMousePosition = { x: e.clientX, y: e.clientY };
                    }

                    // Throttle hover checks for performance
                    const now = Date.now();
                    if (!this.isDragging && now - this.lastHoverCheck > this.hoverCheckInterval) {
                        this.checkWindowHover();
                        this.lastHoverCheck = now;
                    }
                });

                this.renderer.domElement.addEventListener('mouseup', () => {
                    // Only trigger click if not dragged
                    if (!this.isDragging && this.dragDistance < this.dragThreshold) {
                        this.checkWindowClick();
                    }
                    this.isDragging = false;
                    this.dragDistance = 0;
                    this.previousMousePosition = { x: 0, y: 0 };
                });

                // Touch controls with improved gesture detection
                let touchStartX = 0, touchStartY = 0;
                let touchDragDistance = 0;

                this.renderer.domElement.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                        touchDragDistance = 0;

                        // Update mouse position for raycasting
                        this.mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                        this.mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
                    }
                }, { passive: true });

                this.renderer.domElement.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1) {
                        const deltaX = e.touches[0].clientX - touchStartX;
                        const deltaY = e.touches[0].clientY - touchStartY;
                        touchDragDistance += Math.abs(deltaX) + Math.abs(deltaY);

                        this.targetCameraRotation.y -= deltaX * 0.003;
                        this.targetCameraRotation.x -= deltaY * 0.003;
                        this.targetCameraRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, this.targetCameraRotation.x));

                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    }
                }, { passive: true });

                this.renderer.domElement.addEventListener('touchend', (e) => {
                    // Only register as click if minimal movement (tap gesture)
                    if (touchDragDistance < this.dragThreshold * 2) {
                        this.checkWindowClick();
                    }
                    touchDragDistance = 0;
                }, { passive: true });

                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'KeyW':
                        case 'ArrowUp':
                            this.moveForward = true;
                            break;
                        case 'KeyS':
                        case 'ArrowDown':
                            this.moveBackward = true;
                            break;
                        case 'KeyA':
                        case 'ArrowLeft':
                            this.moveLeft = true;
                            break;
                        case 'KeyD':
                        case 'ArrowRight':
                            this.moveRight = true;
                            break;
                        case 'Escape':
                            closeDemoInfo();
                            break;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    switch(e.code) {
                        case 'KeyW':
                        case 'ArrowUp':
                            this.moveForward = false;
                            break;
                        case 'KeyS':
                        case 'ArrowDown':
                            this.moveBackward = false;
                            break;
                        case 'KeyA':
                        case 'ArrowLeft':
                            this.moveLeft = false;
                            break;
                        case 'KeyD':
                        case 'ArrowRight':
                            this.moveRight = false;
                            break;
                    }
                });
            }

            checkWindowHover() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(
                    this.windows.map(w => w.mesh)
                );

                // Reset previous hover
                if (this.hoveredWindow) {
                    this.hoveredWindow.mesh.material.emissiveIntensity = 0.4;
                    this.hoveredWindow.light.intensity = 1.5;
                }

                if (intersects.length > 0) {
                    const window = this.windows.find(w => w.mesh === intersects[0].object);
                    if (window) {
                        this.hoveredWindow = window;
                        window.mesh.material.emissiveIntensity = 0.7;
                        window.light.intensity = 3.5;
                        this.renderer.domElement.style.cursor = 'pointer';
                    }
                } else {
                    this.hoveredWindow = null;
                    this.renderer.domElement.style.cursor = 'default';
                }
            }

            checkWindowClick() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(
                    this.windows.map(w => w.mesh)
                );

                if (intersects.length > 0) {
                    const window = this.windows.find(w => w.mesh === intersects[0].object);
                    if (window) {
                        this.showDemoInfo(window.demo);
                    }
                }
            }

            showDemoInfo(demo) {
                const panel = document.getElementById('demoInfoPanel');
                const content = document.getElementById('demoInfoContent');

                content.innerHTML = `
                    <div class="demo-info-icon">${demo.icon}</div>
                    <div class="demo-info-category category-${demo.category}">${demo.category}</div>
                    <h2 class="demo-info-title">${demo.title}</h2>
                    <p class="demo-info-tagline">${demo.tagline}</p>
                    <div class="demo-metrics">
                        ${demo.metrics.map(m => `
                            <div class="metric">
                                <span class="metric-value">${m.value}</span>
                                <span class="metric-label">${m.label}</span>
                            </div>
                        `).join('')}
                    </div>
                    <ul class="demo-features">
                        ${demo.features.map(f => `<li>${f}</li>`).join('')}
                    </ul>
                    <a href="demos/${demo.file}" class="launch-demo-btn">Launch Demo ‚Üí</a>
                `;

                panel.classList.add('active');
            }

            updateCamera() {
                const time = this.clock.getElapsedTime();

                // Smooth camera rotation with easing
                const rotationEase = this.isMobile ? 0.15 : 0.1;
                this.cameraRotation.x += (this.targetCameraRotation.x - this.cameraRotation.x) * rotationEase;
                this.cameraRotation.y += (this.targetCameraRotation.y - this.cameraRotation.y) * rotationEase;

                // Subtle ambient camera sway when idle (no movement keys pressed)
                const isIdle = !this.moveForward && !this.moveBackward && !this.moveLeft && !this.moveRight;
                let ambientX = 0, ambientY = 0;
                if (isIdle && !this.isDragging) {
                    ambientX = Math.sin(time * 0.3) * 0.005;
                    ambientY = Math.cos(time * 0.4) * 0.003;
                }

                // Movement with variable speed
                const moveSpeed = this.isMobile ? 0.25 : 0.3;
                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);

                forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.cameraRotation.y);
                right.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.cameraRotation.y);

                if (this.moveForward) {
                    this.cameraPosition.x += forward.x * moveSpeed;
                    this.cameraPosition.z += forward.z * moveSpeed;
                }
                if (this.moveBackward) {
                    this.cameraPosition.x -= forward.x * moveSpeed;
                    this.cameraPosition.z -= forward.z * moveSpeed;
                }
                if (this.moveLeft) {
                    this.cameraPosition.x -= right.x * moveSpeed;
                    this.cameraPosition.z -= right.z * moveSpeed;
                }
                if (this.moveRight) {
                    this.cameraPosition.x += right.x * moveSpeed;
                    this.cameraPosition.z += right.z * moveSpeed;
                }

                // Constrain movement within cathedral with soft bounds
                const boundPadding = 2;
                this.cameraPosition.x = Math.max(-20 + boundPadding, Math.min(20 - boundPadding, this.cameraPosition.x));
                this.cameraPosition.z = Math.max(-25 + boundPadding, Math.min(25 - boundPadding, this.cameraPosition.z));

                // Apply camera transformation with ambient sway
                this.camera.position.set(this.cameraPosition.x, this.cameraPosition.y, this.cameraPosition.z);
                this.camera.rotation.set(this.cameraRotation.x + ambientX, this.cameraRotation.y + ambientY, 0);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const time = this.clock.getElapsedTime();

                // Animate particles with floating motion
                if (this.particles) {
                    this.particles.rotation.y = time * 0.02;
                    this.particles.position.y = Math.sin(time * 0.3) * 0.5;

                    // Add subtle particle drift (only on desktop for performance)
                    if (!this.isLowPerformance) {
                        const positions = this.particles.geometry.attributes.position;
                        const velocities = this.particles.geometry.attributes.velocity;

                        for (let i = 0; i < positions.count; i++) {
                            positions.array[i * 3] += velocities.array[i * 3];
                            positions.array[i * 3 + 1] += velocities.array[i * 3 + 1];
                            positions.array[i * 3 + 2] += velocities.array[i * 3 + 2];

                            // Wrap particles that drift too far
                            if (Math.abs(positions.array[i * 3]) > 25) positions.array[i * 3] *= -0.9;
                            if (positions.array[i * 3 + 1] > 30 || positions.array[i * 3 + 1] < 0) {
                                velocities.array[i * 3 + 1] *= -0.5;
                            }
                            if (Math.abs(positions.array[i * 3 + 2]) > 30) positions.array[i * 3 + 2] *= -0.9;
                        }
                        positions.needsUpdate = true;
                    }
                }

                // Pulse window lights with variety
                this.windows.forEach((window, index) => {
                    const offset = index * 0.5;
                    const intensity = 1.5 + Math.sin(time * 0.7 + offset) * 0.5;
                    if (window !== this.hoveredWindow) {
                        window.light.intensity = intensity;
                        // Subtle emissive pulse
                        window.mesh.material.emissiveIntensity = 0.4 + Math.sin(time * 0.7 + offset) * 0.1;
                    }
                });

                this.updateCamera();
                this.renderer.render(this.scene, this.camera);
            }

            // Resource cleanup for memory management
            dispose() {
                // Dispose geometries and materials
                this.scene.traverse((object) => {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });

                // Dispose renderer
                if (this.renderer) {
                    this.renderer.dispose();
                }

                // Clear references
                this.windows = [];
                this.hoveredWindow = null;
            }
        }

        function closeDemoInfo() {
            document.getElementById('demoInfoPanel').classList.remove('active');
        }

        // Initialize with error handling
        window.addEventListener('DOMContentLoaded', () => {
            try {
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js failed to load');
                }

                // Check for WebGL support
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    throw new Error('WebGL not supported');
                }

                new CathedralExperience();
            } catch (error) {
                console.error('Cathedral initialization failed:', error);
                const loading = document.getElementById('loading');
                loading.innerHTML = 'Failed to load 3D experience.<br><small>Please try a different browser or device.</small>';
                loading.style.color = 'rgba(255, 100, 100, 0.8)';
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (window.cathedralInstance) {
                window.cathedralInstance.dispose();
            }
        });
    </script>
</body>
</html>
